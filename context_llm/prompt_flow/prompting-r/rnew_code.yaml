Implement code by following the MONOCODE guidelines of modularity and simplicity and by following the CODE_EXPANSION guidelines of preserving working code. And by following the NEW_CODE guidelines.

MONOCODE
  ```yaml
  ---
  # Application
  Generate the code leveraging a dynamic programming approach, modularity, and maintainability. Create as many modules as possible to:

  1.    Divide problems into smaller sub-problems  : Break down complex issues into manageable, bite-sized pieces.
  2.    Enhance code readability and maintainability  : Organize code into logical, easy-to-follow modules.
  3.    Promote code reusability  : Enable the reuse of individual modules in other parts of the project or different projects.

  For the code inside each module, prioritize:

  1.    Clarity  : Ensure the code is easy to understand and follow.
  2.    Brevity  : Strive for efficient performance using the fewest code lines possible.
  3.    Readability  : Use meaningful variable names and comments to explain complex logic.
  4.    Simplicity  : Optimize for straightforward, easy-to-understand code.
  5.    Efficaciousness  : Prioritize effective functionality and efficient performance.
  6.    Minimalism  : Minimize code complexity; code is a liability, not an asset.

  ---
  # Definition
  mono_code:
    description: >-
      A codebase emphasizing clarity, conciseness, and minimalism to ensure a robust
      and error-free foundation for further development 

  # High-Level Principles
    - Utilize dynamic programming to divide problems into smaller sub-problems.
    - Minimize code complexity; code is a liability, not an asset. Always optimize for simplicity and efficaciousness (i.e. being effective and provide functional code, and being efficient and provide as few code lines as possible that have great performance).
    - Prioritize simplicity, brevity, readability, and maintainability.
    - Optimize for efficiency and performance.
  ```
END_MONOCODE

CODE_EXPANSION
```yaml
code_modification_guidelines:
  - principle: "Maintain functionality"
    description: "Do not modify working code unless an explicit instruction is provided."
  - principle: "Explicit instruction required"
    description: "Only change code when you receive a clear, explicit instruction stating that the current functionality is not working or needs improvement."
  - principle: "Protect working code"
    description: "If a piece of code is functioning as intended, leave it unchanged to ensure the current functionality remains intact."
  - principle: "Respect stability"
    description: "Focus on preserving the stability of the existing codebase, and avoid unnecessary changes."
  - principle: "Document changes"
    description: "If a change is made based on an explicit instruction, document the reason and the specific issue that prompted the change."
```
END_CODE_EXPANSION

NEW_CODE
  Reason step by step using the nlir_reasoning framework (generate initial question, sub-questions, answers and states) and snlot_describing framework (detailed output), to generate new code.

 NLIR First Principles
  ```yaml
  first_principles:
    nlir_reasoning: 
      - Utilize the Natural Language Inherent Reasoning (NLIR) framework to break down the problem into a structured series of sub-questions and answers.
      -  Employ a flow of questions, starting with a high-level question and progressively breaking it down into more manageable sub-questions.
      - **Structured Response Framework:**
        - Employ the Structured Response Framework to formulate answers to sub-questions:
          - **Structured Natural Language Templates:** Use predefined templates that mimic programming structures (e.g., "If [condition], then [action], otherwise [alternative action]").
          - **Decision Trees in Text:** Create textual decision trees for classification or complex decision-making.
          - **State-based Reasoning:**  After answering each sub-question, describe the current state of the problem in clear natural language. Update this state based on the answer to the sub-question.
      - **Advantages:**
        - NLIR promotes accuracy by providing a structured reasoning framework that minimizes ambiguity.
        - The use of natural language throughout the process enhances interpretability, making the reasoning steps transparent and understandable. 
    flow_of_thought:
      - Think step-by-step, systematically addressing each sub-question and updating the problem state accordingly. 
      - Explicitly describe the reasoning behind each answer and how it affects the overall solution. 
    general_guidelines:
      - Clearly define the initial state of the problem, including any relevant variables or data.
      - Maintain a clear and consistent representation of the problem state throughout the reasoning process.
      - Use precise language and avoid ambiguity when describing conditions, actions, and states.
  ```
  ---
  sNLOT First Principles
  ```yaml
  first_principles:
    snlot_describing: 
      - Utilize the Simplified Natural Language Output Tree (sNLOT) framework to fill any gap left by the user when stating his request when defining every major and minor detail (requirements) that his expected output must have. 
      - Employ flow of completion when the user request is ambiguous, vague or incomplete, generating high-level, minor and sub-minor requirements the best output should have based on your own criteria and reasoning.
      - Advantages:
        - sNLOT facilitates the identification of missing or ambiguous requirements, reducing the risk of misinterpretation or incorrect output.
      - General Guidelines:
        - Use clear and concise language when describing each requirement, avoiding ambiguity and jargon.
  ```
END_NEW_CODE

NOTE // Generate your response without any markdown formatting or styling, and only use backticks for code snippets. 

